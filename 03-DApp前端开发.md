# ç¬¬ä¸‰ç« ï¼šDAppå‰ç«¯å¼€å‘ ğŸ¨

## 3.1 WEB3å‰ç«¯æŠ€æœ¯æ ˆ

### å®Œæ•´æŠ€æœ¯æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        å‰ç«¯æ¡†æ¶å±‚                        â”‚
â”‚   React / Vue / Next.js / Nuxt.js       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        WEB3äº¤äº’å±‚                        â”‚
â”‚   Web3.js / Ethers.js / Viem            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        é’±åŒ…è¿æ¥å±‚                        â”‚
â”‚   MetaMask / WalletConnect / RainbowKit â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        åŒºå—é“¾RPCå±‚                       â”‚
â”‚   Infura / Alchemy / QuickNode          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚        åŒºå—é“¾ç½‘ç»œ                        â”‚
â”‚   Ethereum / BSC / Polygon              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒåº“å¯¹æ¯”

| ç‰¹æ€§           | Web3.js  | Ethers.js | Viem     |
| -------------- | -------- | --------- | -------- |
| **å¤§å°**       | ~1.1MB   | ~116KB    | ~60KB    |
| **æ€§èƒ½**       | ä¸­ç­‰     | è‰¯å¥½      | ä¼˜ç§€     |
| **TypeScript** | éƒ¨åˆ†æ”¯æŒ | å®Œå…¨æ”¯æŒ  | å®Œå…¨æ”¯æŒ |
| **å­¦ä¹ æ›²çº¿**   | é™¡å³­     | å¹³ç¼“      | å¹³ç¼“     |
| **ç¤¾åŒº**       | æœ€å¤§     | å¿«é€Ÿå¢é•¿  | æ–°å…´     |
| **æ¨èåº¦**     | â­â­â­      | â­â­â­â­â­     | â­â­â­â­     |

**æ¨èé€‰æ‹©**ï¼šEthers.jsï¼ˆå¹³è¡¡äº†æ€§èƒ½ã€æ˜“ç”¨æ€§å’Œç”Ÿæ€ï¼‰

## 3.2 Ethers.js å®Œå…¨æŒ‡å—

### å®‰è£…å’ŒåŸºæœ¬è®¾ç½®

```bash
# å®‰è£… ethers.js
npm install ethers

# æˆ–ä½¿ç”¨ yarn
yarn add ethers
```

### 3.2.1 è¿æ¥åˆ°ç½‘ç»œ

```javascript
import { ethers } from 'ethers';

// æ–¹å¼1: è¿æ¥åˆ°MetaMaskç­‰æµè§ˆå™¨é’±åŒ…
const provider = new ethers.BrowserProvider(window.ethereum);

// æ–¹å¼2: ä½¿ç”¨RPC URLè¿æ¥
const provider = new ethers.JsonRpcProvider('https://eth-sepolia.g.alchemy.com/v2/YOUR-API-KEY');

// æ–¹å¼3: ä½¿ç”¨Infura
const provider = new ethers.InfuraProvider('sepolia', 'YOUR-INFURA-PROJECT-ID');

// è·å–ç½‘ç»œä¿¡æ¯
const network = await provider.getNetwork();
console.log('Network:', network.name);
console.log('Chain ID:', network.chainId);

// è·å–å½“å‰åŒºå—å·
const blockNumber = await provider.getBlockNumber();
console.log('Current block:', blockNumber);
```

### 3.2.2 é’±åŒ…ç®¡ç†

```javascript
// 1. ä»ç§é’¥åˆ›å»ºé’±åŒ…
const wallet = new ethers.Wallet('0xYOUR_PRIVATE_KEY', provider);

// 2. ç”Ÿæˆéšæœºé’±åŒ…
const randomWallet = ethers.Wallet.createRandom();
console.log('Address:', randomWallet.address);
console.log('Mnemonic:', randomWallet.mnemonic.phrase);
console.log('Private Key:', randomWallet.privateKey);

// 3. ä»åŠ©è®°è¯æ¢å¤é’±åŒ…
const mnemonic = 'test test test test test test test test test test test junk';
const walletFromMnemonic = ethers.Wallet.fromPhrase(mnemonic);

// 4. è¿æ¥é’±åŒ…åˆ°provider
const connectedWallet = wallet.connect(provider);

// 5. è·å–é’±åŒ…ä½™é¢
const balance = await provider.getBalance(wallet.address);
console.log('Balance:', ethers.formatEther(balance), 'ETH');
```

### 3.2.3 å‘é€äº¤æ˜“

```javascript
// 1. ç®€å•çš„ETHè½¬è´¦
async function sendEther(to, amount) {
  const tx = await wallet.sendTransaction({
    to: to,
    value: ethers.parseEther(amount)  // è½¬æ¢ETHåˆ°Wei
  });
  
  console.log('Transaction hash:', tx.hash);
  
  // ç­‰å¾…äº¤æ˜“ç¡®è®¤
  const receipt = await tx.wait();
  console.log('Transaction confirmed in block:', receipt.blockNumber);
  
  return receipt;
}

// ä½¿ç”¨ç¤ºä¾‹
await sendEther('0xRecipientAddress', '0.1');

// 2. å¸¦æ•°æ®çš„äº¤æ˜“
const tx = await wallet.sendTransaction({
  to: '0xContractAddress',
  value: ethers.parseEther('0.01'),
  gasLimit: 100000,
  data: '0x...'  // åˆçº¦è°ƒç”¨æ•°æ®
});

// 3. ä¼°ç®—Gas
const gasEstimate = await provider.estimateGas({
  to: '0xAddress',
  value: ethers.parseEther('0.1')
});
console.log('Estimated gas:', gasEstimate.toString());
```

### 3.2.4 ä¸æ™ºèƒ½åˆçº¦äº¤äº’

```javascript
// åˆçº¦ABIï¼ˆä»ç¼–è¯‘åçš„åˆçº¦ä¸­è·å–ï¼‰
const contractABI = [
  "function balanceOf(address owner) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "event Transfer(address indexed from, address indexed to, uint256 amount)"
];

const contractAddress = '0xYourContractAddress';

// åˆ›å»ºåˆçº¦å®ä¾‹
const contract = new ethers.Contract(contractAddress, contractABI, provider);

// åªè¯»è°ƒç”¨ï¼ˆä¸éœ€è¦Gasï¼‰
const balance = await contract.balanceOf('0xUserAddress');
console.log('Balance:', ethers.formatUnits(balance, 18));

// å†™å…¥è°ƒç”¨ï¼ˆéœ€è¦ç­¾åå’ŒGasï¼‰
const contractWithSigner = contract.connect(wallet);
const tx = await contractWithSigner.transfer('0xRecipient', ethers.parseUnits('100', 18));
await tx.wait();

// ç›‘å¬äº‹ä»¶
contract.on('Transfer', (from, to, amount, event) => {
  console.log(`Transfer from ${from} to ${to}: ${ethers.formatUnits(amount, 18)}`);
});

// æŸ¥è¯¢å†å²äº‹ä»¶
const filter = contract.filters.Transfer(null, '0xMyAddress');
const events = await contract.queryFilter(filter, -10000);  // æœ€è¿‘10000ä¸ªåŒºå—
events.forEach(event => {
  console.log('Event:', event.args);
});
```

### 3.2.5 å®Œæ•´çš„ERC-20ä»£å¸äº¤äº’ç¤ºä¾‹

```javascript
// ERC-20 æ ‡å‡†æ¥å£
const ERC20_ABI = [
  "function name() view returns (string)",
  "function symbol() view returns (string)",
  "function decimals() view returns (uint8)",
  "function totalSupply() view returns (uint256)",
  "function balanceOf(address) view returns (uint256)",
  "function transfer(address to, uint256 amount) returns (bool)",
  "function approve(address spender, uint256 amount) returns (bool)",
  "function allowance(address owner, address spender) view returns (uint256)",
  "function transferFrom(address from, address to, uint256 amount) returns (bool)",
  "event Transfer(address indexed from, address indexed to, uint256 value)",
  "event Approval(address indexed owner, address indexed spender, uint256 value)"
];

class TokenManager {
  constructor(tokenAddress, signerOrProvider) {
    this.contract = new ethers.Contract(tokenAddress, ERC20_ABI, signerOrProvider);
  }
  
  // è·å–ä»£å¸ä¿¡æ¯
  async getTokenInfo() {
    const [name, symbol, decimals, totalSupply] = await Promise.all([
      this.contract.name(),
      this.contract.symbol(),
      this.contract.decimals(),
      this.contract.totalSupply()
    ]);
    
    return {
      name,
      symbol,
      decimals,
      totalSupply: ethers.formatUnits(totalSupply, decimals)
    };
  }
  
  // è·å–ä½™é¢
  async getBalance(address) {
    const balance = await this.contract.balanceOf(address);
    const decimals = await this.contract.decimals();
    return ethers.formatUnits(balance, decimals);
  }
  
  // è½¬è´¦
  async transfer(to, amount) {
    const decimals = await this.contract.decimals();
    const tx = await this.contract.transfer(to, ethers.parseUnits(amount, decimals));
    return await tx.wait();
  }
  
  // æˆæƒ
  async approve(spender, amount) {
    const decimals = await this.contract.decimals();
    const tx = await this.contract.approve(spender, ethers.parseUnits(amount, decimals));
    return await tx.wait();
  }
  
  // æŸ¥è¯¢æˆæƒé¢åº¦
  async getAllowance(owner, spender) {
    const allowance = await this.contract.allowance(owner, spender);
    const decimals = await this.contract.decimals();
    return ethers.formatUnits(allowance, decimals);
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const tokenManager = new TokenManager('0xTokenAddress', wallet);
const info = await tokenManager.getTokenInfo();
console.log('Token Info:', info);
```

## 3.3 Reacté›†æˆç¤ºä¾‹

### 3.3.1 åˆ›å»ºWEB3ä¸Šä¸‹æ–‡

```typescript
// contexts/Web3Context.tsx
import React, { createContext, useContext, useState, useEffect } from 'react';
import { ethers } from 'ethers';

interface Web3ContextType {
  provider: ethers.BrowserProvider | null;
  signer: ethers.Signer | null;
  account: string | null;
  chainId: number | null;
  connect: () => Promise<void>;
  disconnect: () => void;
}

const Web3Context = createContext<Web3ContextType | undefined>(undefined);

export function Web3Provider({ children }: { children: React.ReactNode }) {
  const [provider, setProvider] = useState<ethers.BrowserProvider | null>(null);
  const [signer, setSigner] = useState<ethers.Signer | null>(null);
  const [account, setAccount] = useState<string | null>(null);
  const [chainId, setChainId] = useState<number | null>(null);
  
  // è¿æ¥é’±åŒ…
  const connect = async () => {
    if (typeof window.ethereum === 'undefined') {
      alert('Please install MetaMask!');
      return;
    }
    
    try {
      const provider = new ethers.BrowserProvider(window.ethereum);
      const accounts = await provider.send('eth_requestAccounts', []);
      const signer = await provider.getSigner();
      const network = await provider.getNetwork();
      
      setProvider(provider);
      setSigner(signer);
      setAccount(accounts[0]);
      setChainId(Number(network.chainId));
    } catch (error) {
      console.error('Error connecting wallet:', error);
    }
  };
  
  // æ–­å¼€è¿æ¥
  const disconnect = () => {
    setProvider(null);
    setSigner(null);
    setAccount(null);
    setChainId(null);
  };
  
  // ç›‘å¬è´¦æˆ·å˜åŒ–
  useEffect(() => {
    if (window.ethereum) {
      window.ethereum.on('accountsChanged', (accounts: string[]) => {
        if (accounts.length === 0) {
          disconnect();
        } else {
          setAccount(accounts[0]);
        }
      });
      
      window.ethereum.on('chainChanged', () => {
        window.location.reload();
      });
    }
    
    return () => {
      if (window.ethereum) {
        window.ethereum.removeAllListeners();
      }
    };
  }, []);
  
  return (
    <Web3Context.Provider value={{ provider, signer, account, chainId, connect, disconnect }}>
      {children}
    </Web3Context.Provider>
  );
}

export function useWeb3() {
  const context = useContext(Web3Context);
  if (!context) {
    throw new Error('useWeb3 must be used within Web3Provider');
  }
  return context;
}
```

### 3.3.2 é’±åŒ…è¿æ¥ç»„ä»¶

```typescript
// components/WalletConnect.tsx
import React from 'react';
import { useWeb3 } from '../contexts/Web3Context';

export function WalletConnect() {
  const { account, chainId, connect, disconnect } = useWeb3();
  
  const formatAddress = (address: string) => {
    return `${address.slice(0, 6)}...${address.slice(-4)}`;
  };
  
  const getNetworkName = (chainId: number) => {
    const networks: Record<number, string> = {
      1: 'Ethereum',
      5: 'Goerli',
      11155111: 'Sepolia',
      56: 'BSC',
      137: 'Polygon'
    };
    return networks[chainId] || 'Unknown';
  };
  
  return (
    <div className="wallet-connect">
      {!account ? (
        <button onClick={connect} className="connect-button">
          Connect Wallet
        </button>
      ) : (
        <div className="wallet-info">
          <span className="network-badge">
            {chainId && getNetworkName(chainId)}
          </span>
          <span className="address">{formatAddress(account)}</span>
          <button onClick={disconnect} className="disconnect-button">
            Disconnect
          </button>
        </div>
      )}
    </div>
  );
}
```

### 3.3.3 ä»£å¸ä½™é¢æŸ¥è¯¢ç»„ä»¶

```typescript
// components/TokenBalance.tsx
import React, { useState, useEffect } from 'react';
import { ethers } from 'ethers';
import { useWeb3 } from '../contexts/Web3Context';

const ERC20_ABI = [
  "function balanceOf(address) view returns (uint256)",
  "function decimals() view returns (uint8)",
  "function symbol() view returns (string)"
];

export function TokenBalance({ tokenAddress }: { tokenAddress: string }) {
  const { provider, account } = useWeb3();
  const [balance, setBalance] = useState<string>('0');
  const [symbol, setSymbol] = useState<string>('');
  const [loading, setLoading] = useState(false);
  
  useEffect(() => {
    if (!provider || !account || !tokenAddress) return;
    
    const fetchBalance = async () => {
      setLoading(true);
      try {
        const contract = new ethers.Contract(tokenAddress, ERC20_ABI, provider);
        const [balance, decimals, symbol] = await Promise.all([
          contract.balanceOf(account),
          contract.decimals(),
          contract.symbol()
        ]);
        
        setBalance(ethers.formatUnits(balance, decimals));
        setSymbol(symbol);
      } catch (error) {
        console.error('Error fetching balance:', error);
      } finally {
        setLoading(false);
      }
    };
    
    fetchBalance();
    
    // æ¯15ç§’åˆ·æ–°ä¸€æ¬¡
    const interval = setInterval(fetchBalance, 15000);
    return () => clearInterval(interval);
  }, [provider, account, tokenAddress]);
  
  if (loading) return <div>Loading...</div>;
  
  return (
    <div className="token-balance">
      <h3>Token Balance</h3>
      <p>{balance} {symbol}</p>
    </div>
  );
}
```

### 3.3.4 ä»£å¸è½¬è´¦ç»„ä»¶

```typescript
// components/TokenTransfer.tsx
import React, { useState } from 'react';
import { ethers } from 'ethers';
import { useWeb3 } from '../contexts/Web3Context';

const ERC20_ABI = [
  "function transfer(address to, uint256 amount) returns (bool)",
  "function decimals() view returns (uint8)"
];

export function TokenTransfer({ tokenAddress }: { tokenAddress: string }) {
  const { signer } = useWeb3();
  const [recipient, setRecipient] = useState('');
  const [amount, setAmount] = useState('');
  const [loading, setLoading] = useState(false);
  const [txHash, setTxHash] = useState('');
  
  const handleTransfer = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!signer || !recipient || !amount) return;
    
    setLoading(true);
    setTxHash('');
    
    try {
      const contract = new ethers.Contract(tokenAddress, ERC20_ABI, signer);
      const decimals = await contract.decimals();
      
      const tx = await contract.transfer(
        recipient,
        ethers.parseUnits(amount, decimals)
      );
      
      setTxHash(tx.hash);
      await tx.wait();
      
      alert('Transfer successful!');
      setRecipient('');
      setAmount('');
    } catch (error: any) {
      console.error('Transfer error:', error);
      alert(error.message || 'Transfer failed');
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div className="token-transfer">
      <h3>Send Tokens</h3>
      <form onSubmit={handleTransfer}>
        <input
          type="text"
          placeholder="Recipient Address"
          value={recipient}
          onChange={(e) => setRecipient(e.target.value)}
          required
        />
        <input
          type="number"
          placeholder="Amount"
          value={amount}
          onChange={(e) => setAmount(e.target.value)}
          step="0.000001"
          min="0"
          required
        />
        <button type="submit" disabled={loading}>
          {loading ? 'Sending...' : 'Send'}
        </button>
      </form>
      {txHash && (
        <div className="tx-info">
          <p>Transaction Hash:</p>
          <a 
            href={`https://etherscan.io/tx/${txHash}`}
            target="_blank"
            rel="noopener noreferrer"
          >
            {txHash}
          </a>
        </div>
      )}
    </div>
  );
}
```

## 3.4 å¸¸ç”¨é’±åŒ…é›†æˆæ–¹æ¡ˆ

### 3.4.1 RainbowKité›†æˆï¼ˆæ¨èï¼‰

```bash
npm install @rainbow-me/rainbowkit wagmi viem@2.x @tanstack/react-query
```

```typescript
// app.tsx
import '@rainbow-me/rainbowkit/styles.css';
import { getDefaultConfig, RainbowKitProvider } from '@rainbow-me/rainbowkit';
import { WagmiProvider } from 'wagmi';
import { mainnet, polygon, optimism, arbitrum } from 'wagmi/chains';
import { QueryClientProvider, QueryClient } from '@tanstack/react-query';

const config = getDefaultConfig({
  appName: 'My DApp',
  projectId: 'YOUR_WALLETCONNECT_PROJECT_ID',
  chains: [mainnet, polygon, optimism, arbitrum],
});

const queryClient = new QueryClient();

function App() {
  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        <RainbowKitProvider>
          {/* Your App */}
        </RainbowKitProvider>
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

### 3.4.2 WalletConnecté›†æˆ

```typescript
import { WalletConnect } from '@walletconnect/web3-provider';

const provider = new WalletConnect({
  infuraId: 'YOUR_INFURA_ID',
  qrcode: true,
});

await provider.enable();
const ethersProvider = new ethers.BrowserProvider(provider);
```

## 3.5 å®ç”¨å·¥å…·å‡½æ•°

```typescript
// utils/web3Utils.ts

// æ ¼å¼åŒ–åœ°å€
export function formatAddress(address: string, length = 4): string {
  return `${address.slice(0, length + 2)}...${address.slice(-length)}`;
}

// æ ¼å¼åŒ–é‡‘é¢
export function formatAmount(amount: string, decimals = 4): string {
  const num = parseFloat(amount);
  return num.toFixed(decimals);
}

// éªŒè¯åœ°å€
export function isValidAddress(address: string): boolean {
  return ethers.isAddress(address);
}

// æ ¼å¼åŒ–äº¤æ˜“å“ˆå¸Œ
export function getEtherscanLink(
  chainId: number,
  hash: string,
  type: 'tx' | 'address' = 'tx'
): string {
  const networks: Record<number, string> = {
    1: 'etherscan.io',
    5: 'goerli.etherscan.io',
    11155111: 'sepolia.etherscan.io',
    56: 'bscscan.com',
    137: 'polygonscan.com',
  };
  
  const baseUrl = networks[chainId] || 'etherscan.io';
  return `https://${baseUrl}/${type}/${hash}`;
}

// ç­‰å¾…äº¤æ˜“ç¡®è®¤
export async function waitForTransaction(
  provider: ethers.Provider,
  txHash: string,
  confirmations = 1
): Promise<ethers.TransactionReceipt> {
  console.log(`Waiting for transaction ${txHash}...`);
  const receipt = await provider.waitForTransaction(txHash, confirmations);
  console.log(`Transaction confirmed in block ${receipt.blockNumber}`);
  return receipt;
}

// é”™è¯¯å¤„ç†
export function handleError(error: any): string {
  if (error.code === 'ACTION_REJECTED') {
    return 'Transaction rejected by user';
  }
  if (error.code === 'INSUFFICIENT_FUNDS') {
    return 'Insufficient funds for transaction';
  }
  if (error.code === 'NETWORK_ERROR') {
    return 'Network error. Please check your connection';
  }
  return error.message || 'Unknown error occurred';
}
```

---

## ğŸ“š æœ¬ç« å°ç»“

DAppå‰ç«¯å¼€å‘éœ€è¦æŒæ¡Web3åº“çš„ä½¿ç”¨ã€é’±åŒ…é›†æˆã€åˆçº¦äº¤äº’ç­‰å…³é”®æŠ€èƒ½ã€‚Ethers.jsæä¾›äº†å¼ºå¤§è€Œæ˜“ç”¨çš„APIï¼Œé…åˆReactç­‰ç°ä»£æ¡†æ¶ï¼Œå¯ä»¥å¿«é€Ÿæ„å»ºç”¨æˆ·å‹å¥½çš„å»ä¸­å¿ƒåŒ–åº”ç”¨ã€‚

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šæˆ‘ä»¬å°†å­¦ä¹ æ™ºèƒ½åˆçº¦çš„æµ‹è¯•ä¸éƒ¨ç½²æµç¨‹ ğŸš€

---

> ğŸ’¡ **æœ€ä½³å®è·µ**ï¼šå§‹ç»ˆåœ¨æµ‹è¯•ç½‘ä¸Šå……åˆ†æµ‹è¯•ï¼Œå¤„ç†æ‰€æœ‰å¯èƒ½çš„é”™è¯¯æƒ…å†µï¼Œæä¾›è‰¯å¥½çš„ç”¨æˆ·åé¦ˆã€‚
