# ç¬¬äºŒç« ï¼šæ™ºèƒ½åˆçº¦å¼€å‘åŸºç¡€ ğŸ“

## 2.1 ä»¥å¤ªåŠæŠ€æœ¯æ¶æ„

### ä»¥å¤ªåŠè™šæ‹Ÿæœº (EVM)

- **å®šä¹‰**ï¼šæ‰§è¡Œæ™ºèƒ½åˆçº¦çš„è¿è¡Œç¯å¢ƒ
- **ç‰¹ç‚¹**ï¼š
  - å›¾çµå®Œå¤‡
  - éš”ç¦»æ‰§è¡Œç¯å¢ƒ
  - Gasæœºåˆ¶æ§åˆ¶èµ„æºæ¶ˆè€—
- **EVMå…¼å®¹é“¾**ï¼šBSCã€Polygonã€Avalancheç­‰

### è´¦æˆ·ç±»å‹

```
å¤–éƒ¨è´¦æˆ· (EOA)                    åˆçº¦è´¦æˆ· (Contract Account)
â”œâ”€ ç”±ç§é’¥æ§åˆ¶                     â”œâ”€ ç”±ä»£ç æ§åˆ¶
â”œâ”€ å¯ä»¥å‘èµ·äº¤æ˜“                   â”œâ”€ è¢«åŠ¨å“åº”äº¤æ˜“
â”œâ”€ æ— ä»£ç å­˜å‚¨                     â”œâ”€ å­˜å‚¨æ™ºèƒ½åˆçº¦ä»£ç 
â””â”€ ç¤ºä¾‹ï¼šMetaMaské’±åŒ…            â””â”€ ç¤ºä¾‹ï¼šUniswapåˆçº¦
```

### äº¤æ˜“ (Transaction)

- **ç»„æˆéƒ¨åˆ†**ï¼š
  - `from`: å‘é€è€…åœ°å€
  - `to`: æ¥æ”¶è€…åœ°å€
  - `value`: è½¬è´¦é‡‘é¢
  - `data`: åˆçº¦è°ƒç”¨æ•°æ®
  - `gas`: Gasé™åˆ¶
  - `gasPrice`: Gasä»·æ ¼
  - `nonce`: äº¤æ˜“åºå·

### Gasæœºåˆ¶

- **Gas**: æ‰§è¡Œæ“ä½œçš„è®¡ç®—å•ä½

- **Gas Price**: æ¯å•ä½Gasçš„ä»·æ ¼ï¼ˆä»¥Gweiè®¡ï¼‰

- **Gas Limit**: æ„¿æ„æ”¯ä»˜çš„æœ€å¤§Gasæ•°é‡

- **è®¡ç®—å…¬å¼**ï¼š

  ```
  äº¤æ˜“è´¹ç”¨ = Gas Used Ã— Gas Price
  ```

- **ç¤ºä¾‹**ï¼š

  ```
  Gas Used: 21000
  Gas Price: 50 Gwei
  æ€»è´¹ç”¨ = 21000 Ã— 50 = 1,050,000 Gwei = 0.00105 ETH
  ```

## 2.2 Solidityè¯­è¨€å…¥é—¨

### åŸºæœ¬è¯­æ³•ç»“æ„

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// åˆçº¦å®šä¹‰
contract MyFirstContract {
    // çŠ¶æ€å˜é‡
    uint256 public myNumber;
    string public myString;
    address public owner;
    
    // æ„é€ å‡½æ•°
    constructor() {
        owner = msg.sender;
        myNumber = 0;
    }
    
    // å‡½æ•°
    function setNumber(uint256 _number) public {
        myNumber = _number;
    }
    
    // è§†å›¾å‡½æ•°ï¼ˆä¸ä¿®æ”¹çŠ¶æ€ï¼‰
    function getNumber() public view returns (uint256) {
        return myNumber;
    }
    
    // çº¯å‡½æ•°ï¼ˆä¸è¯»å–ä¹Ÿä¸ä¿®æ”¹çŠ¶æ€ï¼‰
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;
    }
}
```

### æ•°æ®ç±»å‹

#### å€¼ç±»å‹

```solidity
// å¸ƒå°”å‹
bool public isActive = true;

// æ•´æ•°å‹
uint256 public unsignedInt = 123;  // æ— ç¬¦å·æ•´æ•°
int256 public signedInt = -123;     // æœ‰ç¬¦å·æ•´æ•°

// åœ°å€ç±»å‹
address public userAddress = 0x1234567890123456789012345678901234567890;
address payable public recipient;   // å¯æ¥æ”¶ETHçš„åœ°å€

// å­—èŠ‚ç±»å‹
bytes32 public data;                // å›ºå®šå¤§å°å­—èŠ‚æ•°ç»„
bytes public dynamicBytes;          // åŠ¨æ€å­—èŠ‚æ•°ç»„

// æšä¸¾
enum Status { Pending, Active, Completed }
Status public currentStatus = Status.Pending;
```

#### å¼•ç”¨ç±»å‹

```solidity
// æ•°ç»„
uint[] public dynamicArray;         // åŠ¨æ€æ•°ç»„
uint[5] public fixedArray;          // å›ºå®šå¤§å°æ•°ç»„

// æ˜ å°„ï¼ˆç±»ä¼¼å“ˆå¸Œè¡¨ï¼‰
mapping(address => uint256) public balances;
mapping(address => mapping(address => uint256)) public allowances;

// ç»“æ„ä½“
struct User {
    string name;
    uint256 age;
    address wallet;
}
User public user;

// å­—ç¬¦ä¸²
string public message = "Hello, Web3!";
```

### å‡½æ•°ä¿®é¥°ç¬¦ (Modifiers)

```solidity
contract AccessControl {
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    // å®šä¹‰ä¿®é¥°ç¬¦
    modifier onlyOwner() {
        require(msg.sender == owner, "Not the owner");
        _;  // ç»§ç»­æ‰§è¡Œå‡½æ•°ä½“
    }
    
    modifier validAddress(address _addr) {
        require(_addr != address(0), "Invalid address");
        _;
    }
    
    // ä½¿ç”¨ä¿®é¥°ç¬¦
    function changeOwner(address newOwner) 
        public 
        onlyOwner 
        validAddress(newOwner) 
    {
        owner = newOwner;
    }
}
```

### äº‹ä»¶ (Events)

```solidity
contract EventExample {
    // å®šä¹‰äº‹ä»¶
    event Transfer(address indexed from, address indexed to, uint256 amount);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    function transfer(address to, uint256 amount) public {
        // æ‰§è¡Œè½¬è´¦é€»è¾‘...
        
        // è§¦å‘äº‹ä»¶
        emit Transfer(msg.sender, to, amount);
    }
}
```

### é”™è¯¯å¤„ç†

```solidity
contract ErrorHandling {
    uint256 public value;
    
    // require: éªŒè¯è¾“å…¥æ¡ä»¶
    function setValue(uint256 _value) public {
        require(_value > 0, "Value must be greater than 0");
        value = _value;
    }
    
    // assert: å†…éƒ¨é”™è¯¯æ£€æŸ¥ï¼ˆä¸åº”è¯¥å¤±è´¥ï¼‰
    function divide(uint256 a, uint256 b) public pure returns (uint256) {
        assert(b != 0);  // å†…éƒ¨ä¸€è‡´æ€§æ£€æŸ¥
        return a / b;
    }
    
    // revert: å¤æ‚æ¡ä»¶ä¸‹å›æ»š
    function complexValidation(uint256 _value) public {
        if (_value < 10) {
            revert("Value too small");
        }
        if (_value > 1000) {
            revert("Value too large");
        }
        value = _value;
    }
    
    // è‡ªå®šä¹‰é”™è¯¯ï¼ˆGasä¼˜åŒ–ï¼‰
    error InsufficientBalance(uint256 available, uint256 required);
    
    function withdraw(uint256 amount) public {
        uint256 balance = 100;  // ç¤ºä¾‹ä½™é¢
        if (balance < amount) {
            revert InsufficientBalance({
                available: balance,
                required: amount
            });
        }
    }
}
```

## 2.3 å¸¸è§åˆçº¦æ¨¡å¼

### ERC-20 ä»£å¸æ ‡å‡†ï¼ˆç®€åŒ–ç‰ˆï¼‰

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleERC20 {
    string public name;
    string public symbol;
    uint8 public decimals;
    uint256 public totalSupply;
    
    mapping(address => uint256) public balanceOf;
    mapping(address => mapping(address => uint256)) public allowance;
    
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);
    
    constructor(string memory _name, string memory _symbol, uint256 _totalSupply) {
        name = _name;
        symbol = _symbol;
        decimals = 18;
        totalSupply = _totalSupply * 10**decimals;
        balanceOf[msg.sender] = totalSupply;
    }
    
    function transfer(address to, uint256 amount) public returns (bool) {
        require(balanceOf[msg.sender] >= amount, "Insufficient balance");
        balanceOf[msg.sender] -= amount;
        balanceOf[to] += amount;
        emit Transfer(msg.sender, to, amount);
        return true;
    }
    
    function approve(address spender, uint256 amount) public returns (bool) {
        allowance[msg.sender][spender] = amount;
        emit Approval(msg.sender, spender, amount);
        return true;
    }
    
    function transferFrom(address from, address to, uint256 amount) public returns (bool) {
        require(balanceOf[from] >= amount, "Insufficient balance");
        require(allowance[from][msg.sender] >= amount, "Allowance exceeded");
        
        balanceOf[from] -= amount;
        balanceOf[to] += amount;
        allowance[from][msg.sender] -= amount;
        
        emit Transfer(from, to, amount);
        return true;
    }
}
```

### å¯å‡çº§åˆçº¦æ¨¡å¼ï¼ˆä»£ç†æ¨¡å¼ï¼‰

```solidity
// ä»£ç†åˆçº¦
contract Proxy {
    address public implementation;
    address public admin;
    
    constructor(address _implementation) {
        implementation = _implementation;
        admin = msg.sender;
    }
    
    function upgrade(address newImplementation) external {
        require(msg.sender == admin, "Not admin");
        implementation = newImplementation;
    }
    
    fallback() external payable {
        address impl = implementation;
        assembly {
            calldatacopy(0, 0, calldatasize())
            let result := delegatecall(gas(), impl, 0, calldatasize(), 0, 0)
            returndatacopy(0, 0, returndatasize())
            switch result
            case 0 { revert(0, returndatasize()) }
            default { return(0, returndatasize()) }
        }
    }
}
```

### å¤šç­¾é’±åŒ…æ¨¡å¼

```solidity
contract MultiSigWallet {
    address[] public owners;
    uint256 public required;
    
    struct Transaction {
        address to;
        uint256 value;
        bytes data;
        bool executed;
        uint256 confirmations;
    }
    
    mapping(uint256 => Transaction) public transactions;
    mapping(uint256 => mapping(address => bool)) public confirmations;
    uint256 public transactionCount;
    
    modifier onlyOwner() {
        bool isOwner = false;
        for (uint i = 0; i < owners.length; i++) {
            if (owners[i] == msg.sender) {
                isOwner = true;
                break;
            }
        }
        require(isOwner, "Not an owner");
        _;
    }
    
    constructor(address[] memory _owners, uint256 _required) {
        require(_owners.length > 0, "Owners required");
        require(_required > 0 && _required <= _owners.length, "Invalid required");
        owners = _owners;
        required = _required;
    }
    
    function submitTransaction(address to, uint256 value, bytes memory data) 
        public 
        onlyOwner 
        returns (uint256) 
    {
        uint256 txId = transactionCount;
        transactions[txId] = Transaction({
            to: to,
            value: value,
            data: data,
            executed: false,
            confirmations: 0
        });
        transactionCount++;
        return txId;
    }
    
    function confirmTransaction(uint256 txId) public onlyOwner {
        require(!confirmations[txId][msg.sender], "Already confirmed");
        confirmations[txId][msg.sender] = true;
        transactions[txId].confirmations++;
        
        if (transactions[txId].confirmations >= required) {
            executeTransaction(txId);
        }
    }
    
    function executeTransaction(uint256 txId) internal {
        Transaction storage txn = transactions[txId];
        require(!txn.executed, "Already executed");
        require(txn.confirmations >= required, "Not enough confirmations");
        
        txn.executed = true;
        (bool success, ) = txn.to.call{value: txn.value}(txn.data);
        require(success, "Transaction failed");
    }
}
```

## 2.4 å®‰å…¨æœ€ä½³å®è·µ

### å¸¸è§æ¼æ´

#### 1. é‡å…¥æ”»å‡» (Reentrancy)

```solidity
// âŒ ä¸å®‰å…¨çš„ä»£ç 
contract Vulnerable {
    mapping(address => uint256) public balances;
    
    function withdraw() public {
        uint256 amount = balances[msg.sender];
        // å±é™©ï¼šå…ˆè½¬è´¦ï¼Œåæ›´æ–°çŠ¶æ€
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] = 0;  // å¯èƒ½è¢«é‡å…¥æ”»å‡»
    }
}

// âœ… å®‰å…¨çš„ä»£ç 
contract Safe {
    mapping(address => uint256) public balances;
    bool private locked;
    
    modifier noReentrancy() {
        require(!locked, "No reentrancy");
        locked = true;
        _;
        locked = false;
    }
    
    function withdraw() public noReentrancy {
        uint256 amount = balances[msg.sender];
        balances[msg.sender] = 0;  // å…ˆæ›´æ–°çŠ¶æ€
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}
```

#### 2. æ•´æ•°æº¢å‡º

```solidity
// âœ… Solidity 0.8.0+ è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
contract SafeMath {
    function add(uint256 a, uint256 b) public pure returns (uint256) {
        return a + b;  // è‡ªåŠ¨æ£€æŸ¥æº¢å‡º
    }
}
```

#### 3. è®¿é—®æ§åˆ¶

```solidity
contract AccessControl {
    address public owner;
    
    constructor() {
        owner = msg.sender;
    }
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not authorized");
        _;
    }
    
    function sensitiveFunction() public onlyOwner {
        // åªæœ‰ownerå¯ä»¥è°ƒç”¨
    }
}
```

### å®‰å…¨æ£€æŸ¥æ¸…å•

- âœ… ä½¿ç”¨æœ€æ–°ç¨³å®šç‰ˆSolidityï¼ˆ0.8.0+ï¼‰
- âœ… éµå¾ªChecks-Effects-Interactionsæ¨¡å¼
- âœ… ä½¿ç”¨OpenZeppelinåº“
- âœ… é™åˆ¶Gasæ¶ˆè€—
- âœ… éªŒè¯æ‰€æœ‰å¤–éƒ¨è¾“å…¥
- âœ… ä½¿ç”¨äº‹ä»¶è®°å½•é‡è¦æ“ä½œ
- âœ… è¿›è¡Œä¸“ä¸šå®‰å…¨å®¡è®¡
- âœ… è®¾ç½®ç´§æ€¥æš‚åœæœºåˆ¶

## 2.5 å¼€å‘å·¥å…·é“¾

### Hardhat - ä¸“ä¸šå¼€å‘ç¯å¢ƒ

```javascript
// hardhat.config.js
require("@nomicfoundation/hardhat-toolbox");

module.exports = {
  solidity: "0.8.20",
  networks: {
    hardhat: {},
    sepolia: {
      url: "https://sepolia.infura.io/v3/YOUR-PROJECT-ID",
      accounts: [process.env.PRIVATE_KEY]
    }
  },
  etherscan: {
    apiKey: process.env.ETHERSCAN_API_KEY
  }
};
```

### Remix IDE - åœ¨çº¿å¼€å‘å·¥å…·

- **ä¼˜ç‚¹**ï¼š
  - æ— éœ€å®‰è£…ï¼Œæµè§ˆå™¨è®¿é—®
  - å³æ—¶ç¼–è¯‘å’Œéƒ¨ç½²
  - å†…ç½®è°ƒè¯•å™¨
  - é€‚åˆå­¦ä¹ å’Œå¿«é€ŸåŸå‹
- **è®¿é—®**ï¼šhttps://remix.ethereum.org

### Foundry - Rustç¼–å†™çš„å¿«é€Ÿå·¥å…·

```bash
# å®‰è£…
curl -L https://foundry.paradigm.xyz | bash
foundryup

# åˆ›å»ºé¡¹ç›®
forge init my-project
cd my-project

# ç¼–è¯‘
forge build

# æµ‹è¯•
forge test
```

## 2.6 å®æˆ˜ï¼šåˆ›å»ºç¬¬ä¸€ä¸ªæ™ºèƒ½åˆçº¦

### ç®€å•çš„æŠ•ç¥¨åˆçº¦

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract SimpleVoting {
    struct Proposal {
        string description;
        uint256 voteCount;
        bool exists;
    }
    
    mapping(uint256 => Proposal) public proposals;
    mapping(address => mapping(uint256 => bool)) public hasVoted;
    uint256 public proposalCount;
    
    event ProposalCreated(uint256 indexed proposalId, string description);
    event Voted(address indexed voter, uint256 indexed proposalId);
    
    function createProposal(string memory description) public {
        proposals[proposalCount] = Proposal({
            description: description,
            voteCount: 0,
            exists: true
        });
        
        emit ProposalCreated(proposalCount, description);
        proposalCount++;
    }
    
    function vote(uint256 proposalId) public {
        require(proposals[proposalId].exists, "Proposal does not exist");
        require(!hasVoted[msg.sender][proposalId], "Already voted");
        
        proposals[proposalId].voteCount++;
        hasVoted[msg.sender][proposalId] = true;
        
        emit Voted(msg.sender, proposalId);
    }
    
    function getProposal(uint256 proposalId) 
        public 
        view 
        returns (string memory description, uint256 voteCount) 
    {
        require(proposals[proposalId].exists, "Proposal does not exist");
        Proposal memory p = proposals[proposalId];
        return (p.description, p.voteCount);
    }
}
```

---

## ğŸ“š æœ¬ç« å°ç»“

æ™ºèƒ½åˆçº¦æ˜¯WEB3çš„æ ¸å¿ƒï¼ŒSolidityæ˜¯æœ€æµè¡Œçš„æ™ºèƒ½åˆçº¦è¯­è¨€ã€‚æŒæ¡åŸºæœ¬è¯­æ³•ã€å¸¸è§æ¨¡å¼å’Œå®‰å…¨å®è·µæ˜¯æˆä¸ºä¼˜ç§€åŒºå—é“¾å¼€å‘è€…çš„åŸºç¡€ã€‚

**ä¸‹ä¸€ç« é¢„å‘Š**ï¼šæˆ‘ä»¬å°†å­¦ä¹ å¦‚ä½•ä½¿ç”¨Web3.jså’ŒEthers.jsä¸æ™ºèƒ½åˆçº¦äº¤äº’ ğŸ”Œ

---

> ğŸ’¡ **å®è·µå»ºè®®**ï¼šåœ¨Remixä¸Šç¼–å†™å’Œéƒ¨ç½²è¿™äº›ç¤ºä¾‹åˆçº¦ï¼Œåœ¨æµ‹è¯•ç½‘ï¼ˆSepoliaæˆ–Goerliï¼‰ä¸Šå®éªŒã€‚
