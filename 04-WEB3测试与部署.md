# 第四章：WEB3测试与部署 🧪

## 4.1 测试的重要性

### 为什么WEB3测试至关重要？

智能合约一旦部署到主网，**代码不可修改**。这意味着：

- ❌ 无法像传统应用一样打补丁
- ❌ 漏洞会直接导致资金损失
- ❌ 影响用户信任和项目声誉

**历史教训**：

- **The DAO事件（2016）**：损失360万ETH（约5000万美元）
- **Parity钱包漏洞（2017）**：冻结51.3万ETH
- **Poly Network被盗（2021）**：损失6.1亿美元（后被归还）

### 测试金字塔

```
           /\
          /  \  E2E测试 (10%)
         /    \  - 完整流程测试
        /------\  - 前后端集成
       /        \
      / 集成测试  \ (30%)
     /  - 合约交互 \
    /   - 多合约协作\
   /----------------\
  /                  \
 /     单元测试       \ (60%)
/  - 函数级别测试      \
- 边界条件验证        \
/________________________\
```

## 4.2 Hardhat测试框架

### 4.2.1 环境搭建

```bash
# 创建项目目录
mkdir my-dapp
cd my-dapp

# 初始化npm项目
npm init -y

# 安装Hardhat和依赖
npm install --save-dev hardhat
npm install --save-dev @nomicfoundation/hardhat-toolbox
npm install --save-dev @nomicfoundation/hardhat-chai-matchers
npm install --save-dev @nomicfoundation/hardhat-ethers
npm install --save-dev @typechain/hardhat

# 初始化Hardhat项目
npx hardhat init
# 选择: Create a TypeScript project
```

### 4.2.2 Hardhat配置

```typescript
// hardhat.config.ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.20",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
      },
    },
  },
  networks: {
    // 本地测试网络
    hardhat: {
      chainId: 31337,
    },
    // Sepolia测试网
    sepolia: {
      url: process.env.SEPOLIA_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 11155111,
    },
    // BSC测试网
    bscTestnet: {
      url: "https://data-seed-prebsc-1-s1.binance.org:8545",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 97,
    },
    // 主网配置（生产环境）
    mainnet: {
      url: process.env.MAINNET_RPC_URL || "",
      accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : [],
      chainId: 1,
    },
  },
  etherscan: {
    apiKey: {
      mainnet: process.env.ETHERSCAN_API_KEY || "",
      sepolia: process.env.ETHERSCAN_API_KEY || "",
      bscTestnet: process.env.BSCSCAN_API_KEY || "",
    },
  },
  gasReporter: {
    enabled: process.env.REPORT_GAS === "true",
    currency: "USD",
    coinmarketcap: process.env.COINMARKETCAP_API_KEY,
  },
};

export default config;
```

### 4.2.3 环境变量配置

```bash
# .env
SEPOLIA_RPC_URL=https://eth-sepolia.g.alchemy.com/v2/YOUR-API-KEY
MAINNET_RPC_URL=https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY
PRIVATE_KEY=your_private_key_here
ETHERSCAN_API_KEY=your_etherscan_api_key
BSCSCAN_API_KEY=your_bscscan_api_key
COINMARKETCAP_API_KEY=your_coinmarketcap_api_key
REPORT_GAS=true
```

## 4.3 编写测试用例

### 4.3.1 基础测试示例

```typescript
// test/Token.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { loadFixture } from "@nomicfoundation/hardhat-toolbox/network-helpers";

describe("SimpleToken", function () {
  // 使用Fixture提高测试效率
  async function deployTokenFixture() {
    const [owner, addr1, addr2] = await ethers.getSigners();
    
    const Token = await ethers.getContractFactory("SimpleToken");
    const token = await Token.deploy("MyToken", "MTK", ethers.parseEther("1000000"));
    await token.waitForDeployment();
    
    return { token, owner, addr1, addr2 };
  }
  
  describe("部署测试", function () {
    it("应该正确设置代币名称和符号", async function () {
      const { token } = await loadFixture(deployTokenFixture);
      
      expect(await token.name()).to.equal("MyToken");
      expect(await token.symbol()).to.equal("MTK");
    });
    
    it("应该将总供应量分配给部署者", async function () {
      const { token, owner } = await loadFixture(deployTokenFixture);
      
      const totalSupply = await token.totalSupply();
      const ownerBalance = await token.balanceOf(owner.address);
      
      expect(ownerBalance).to.equal(totalSupply);
    });
  });
  
  describe("交易测试", function () {
    it("应该能够转账代币", async function () {
      const { token, owner, addr1 } = await loadFixture(deployTokenFixture);
      
      const transferAmount = ethers.parseEther("100");
      
      // 执行转账
      await expect(token.transfer(addr1.address, transferAmount))
        .to.emit(token, "Transfer")
        .withArgs(owner.address, addr1.address, transferAmount);
      
      // 验证余额
      expect(await token.balanceOf(addr1.address)).to.equal(transferAmount);
    });
    
    it("应该在余额不足时失败", async function () {
      const { token, addr1, addr2 } = await loadFixture(deployTokenFixture);
      
      await expect(
        token.connect(addr1).transfer(addr2.address, ethers.parseEther("1"))
      ).to.be.revertedWith("Insufficient balance");
    });
    
    it("应该正确处理授权转账", async function () {
      const { token, owner, addr1, addr2 } = await loadFixture(deployTokenFixture);
      
      const approveAmount = ethers.parseEther("50");
      const transferAmount = ethers.parseEther("30");
      
      // 授权
      await token.approve(addr1.address, approveAmount);
      expect(await token.allowance(owner.address, addr1.address))
        .to.equal(approveAmount);
      
      // 使用授权额度转账
      await expect(
        token.connect(addr1).transferFrom(owner.address, addr2.address, transferAmount)
      ).to.emit(token, "Transfer")
        .withArgs(owner.address, addr2.address, transferAmount);
      
      // 验证剩余授权额度
      expect(await token.allowance(owner.address, addr1.address))
        .to.equal(approveAmount - transferAmount);
    });
  });
  
  describe("边界测试", function () {
    it("应该拒绝向零地址转账", async function () {
      const { token } = await loadFixture(deployTokenFixture);
      
      await expect(
        token.transfer(ethers.ZeroAddress, ethers.parseEther("1"))
      ).to.be.revertedWith("Invalid address");
    });
    
    it("应该处理零金额转账", async function () {
      const { token, addr1 } = await loadFixture(deployTokenFixture);
      
      await expect(token.transfer(addr1.address, 0))
        .to.not.be.reverted;
    });
  });
});
```

### 4.3.2 时间和区块操作测试

```typescript
// test/TimeLock.test.ts
import { time, mine } from "@nomicfoundation/hardhat-toolbox/network-helpers";

describe("TimeLock", function () {
  it("应该在锁定期后允许提取", async function () {
    const { timeLock, owner } = await loadFixture(deployTimeLockFixture);
    
    const lockDuration = 365 * 24 * 60 * 60; // 1年
    const depositAmount = ethers.parseEther("10");
    
    // 存款
    await timeLock.deposit({ value: depositAmount });
    
    // 尝试立即提取（应该失败）
    await expect(timeLock.withdraw()).to.be.revertedWith("Still locked");
    
    // 快进时间
    await time.increase(lockDuration);
    
    // 现在应该可以提取
    await expect(timeLock.withdraw()).to.not.be.reverted;
  });
  
  it("应该在特定区块后执行", async function () {
    const currentBlock = await ethers.provider.getBlockNumber();
    const targetBlock = currentBlock + 100;
    
    // 挖掘区块
    await mine(100);
    
    const newBlock = await ethers.provider.getBlockNumber();
    expect(newBlock).to.be.gte(targetBlock);
  });
  
  it("应该模拟快照和恢复", async function () {
    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);
    
    // 获取初始余额
    const initialBalance = await token.balanceOf(owner.address);
    
    // 创建快照
    const snapshotId = await ethers.provider.send("evm_snapshot", []);
    
    // 进行一些操作
    await token.transfer(addr1.address, ethers.parseEther("100"));
    
    // 恢复到快照
    await ethers.provider.send("evm_revert", [snapshotId]);
    
    // 余额应该恢复
    expect(await token.balanceOf(owner.address)).to.equal(initialBalance);
  });
});
```

### 4.3.3 Gas优化测试

```typescript
describe("Gas优化测试", function () {
  it("应该比较不同实现的Gas消耗", async function () {
    const { token, addr1 } = await loadFixture(deployTokenFixture);
    
    // 单次转账
    const tx1 = await token.transfer(addr1.address, ethers.parseEther("1"));
    const receipt1 = await tx1.wait();
    console.log("单次转账 Gas:", receipt1.gasUsed.toString());
    
    // 批量转账
    const recipients = [addr1.address, addr1.address, addr1.address];
    const amounts = [
      ethers.parseEther("1"),
      ethers.parseEther("1"),
      ethers.parseEther("1")
    ];
    
    const tx2 = await token.batchTransfer(recipients, amounts);
    const receipt2 = await tx2.wait();
    console.log("批量转账 Gas:", receipt2.gasUsed.toString());
    
    // 批量应该更省Gas
    expect(receipt2.gasUsed).to.be.lt(receipt1.gasUsed * BigInt(3));
  });
});
```

### 4.3.4 事件测试

```typescript
describe("事件测试", function () {
  it("应该触发Transfer事件", async function () {
    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);
    
    await expect(token.transfer(addr1.address, ethers.parseEther("10")))
      .to.emit(token, "Transfer")
      .withArgs(owner.address, addr1.address, ethers.parseEther("10"));
  });
  
  it("应该触发多个事件", async function () {
    const { token, owner, addr1 } = await loadFixture(deployTokenFixture);
    
    const tx = await token.approve(addr1.address, ethers.parseEther("100"));
    
    await expect(tx)
      .to.emit(token, "Approval")
      .withArgs(owner.address, addr1.address, ethers.parseEther("100"));
  });
});
```

## 4.4 高级测试技巧

### 4.4.1 模拟账户（Impersonation）

```typescript
import { impersonateAccount, setBalance } from "@nomicfoundation/hardhat-toolbox/network-helpers";

it("应该能够模拟任意账户", async function () {
  const whaleAddress = "0xSomeRichAddress";
  
  // 给模拟账户添加ETH
  await setBalance(whaleAddress, ethers.parseEther("100"));
  
  // 模拟该账户
  await impersonateAccount(whaleAddress);
  const whaleSigner = await ethers.getSigner(whaleAddress);
  
  // 使用模拟账户进行操作
  await token.connect(whaleSigner).transfer(addr1.address, ethers.parseEther("1000"));
});
```

### 4.4.2 Fork主网测试

```typescript
// hardhat.config.ts
networks: {
  hardhat: {
    forking: {
      url: "https://eth-mainnet.g.alchemy.com/v2/YOUR-API-KEY",
      blockNumber: 18000000, // 固定区块以保持一致性
    },
  },
}

// 测试
it("应该与真实Uniswap交互", async function () {
  const UNISWAP_ROUTER = "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D";
  const router = await ethers.getContractAt("IUniswapV2Router02", UNISWAP_ROUTER);
  
  // 在fork的主网上测试
  const path = [WETH, USDC];
  const amounts = await router.getAmountsOut(ethers.parseEther("1"), path);
  console.log("1 ETH =", ethers.formatUnits(amounts[1], 6), "USDC");
});
```

### 4.4.3 覆盖率测试

```bash
# 安装coverage插件
npm install --save-dev solidity-coverage

# 运行覆盖率测试
npx hardhat coverage
```

```typescript
// hardhat.config.ts
import "solidity-coverage";
```

## 4.5 部署流程

### 4.5.1 部署脚本

```typescript
// scripts/deploy.ts
import { ethers } from "hardhat";

async function main() {
  console.log("开始部署...");
  
  // 获取部署者账户
  const [deployer] = await ethers.getSigners();
  console.log("部署账户:", deployer.address);
  console.log("账户余额:", ethers.formatEther(await ethers.provider.getBalance(deployer.address)));
  
  // 部署合约
  const Token = await ethers.getContractFactory("SimpleToken");
  console.log("正在部署Token合约...");
  
  const token = await Token.deploy(
    "MyToken",
    "MTK",
    ethers.parseEther("1000000")
  );
  
  await token.waitForDeployment();
  const tokenAddress = await token.getAddress();
  
  console.log("Token合约已部署到:", tokenAddress);
  
  // 验证部署
  const name = await token.name();
  const totalSupply = await token.totalSupply();
  console.log("Token名称:", name);
  console.log("总供应量:", ethers.formatEther(totalSupply));
  
  // 保存部署信息
  const deployment = {
    network: (await ethers.provider.getNetwork()).name,
    contractAddress: tokenAddress,
    deployer: deployer.address,
    timestamp: new Date().toISOString(),
  };
  
  console.log("\n部署信息:", JSON.stringify(deployment, null, 2));
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
```

### 4.5.2 分步部署复杂系统

```typescript
// scripts/deploy-full-system.ts
async function main() {
  const [deployer] = await ethers.getSigners();
  
  // 1. 部署代币合约
  console.log("1. 部署Token合约...");
  const Token = await ethers.getContractFactory("Token");
  const token = await Token.deploy();
  await token.waitForDeployment();
  console.log("✅ Token:", await token.getAddress());
  
  // 2. 部署治理合约
  console.log("\n2. 部署Governance合约...");
  const Governance = await ethers.getContractFactory("Governance");
  const governance = await Governance.deploy(await token.getAddress());
  await governance.waitForDeployment();
  console.log("✅ Governance:", await governance.getAddress());
  
  // 3. 部署金库合约
  console.log("\n3. 部署Treasury合约...");
  const Treasury = await ethers.getContractFactory("Treasury");
  const treasury = await Treasury.deploy(await governance.getAddress());
  await treasury.waitForDeployment();
  console.log("✅ Treasury:", await treasury.getAddress());
  
  // 4. 初始化配置
  console.log("\n4. 初始化配置...");
  await governance.setTreasury(await treasury.getAddress());
  await treasury.transferOwnership(await governance.getAddress());
  console.log("✅ 配置完成");
  
  // 5. 验证部署
  console.log("\n5. 验证部署...");
  const treasuryAddress = await governance.treasury();
  if (treasuryAddress === await treasury.getAddress()) {
    console.log("✅ 部署验证成功");
  } else {
    throw new Error("部署验证失败");
  }
  
  // 保存合约地址
  const addresses = {
    token: await token.getAddress(),
    governance: await governance.getAddress(),
    treasury: await treasury.getAddress(),
  };
  
  console.log("\n📝 合约地址:", JSON.stringify(addresses, null, 2));
}
```

### 4.5.3 使用Hardhat Ignition部署

```typescript
// ignition/modules/Token.ts
import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

export default buildModule("TokenModule", (m) => {
  const name = m.getParameter("name", "MyToken");
  const symbol = m.getParameter("symbol", "MTK");
  const initialSupply = m.getParameter("initialSupply", ethers.parseEther("1000000"));
  
  const token = m.contract("SimpleToken", [name, symbol, initialSupply]);
  
  return { token };
});
```

```bash
# 部署
npx hardhat ignition deploy ignition/modules/Token.ts --network sepolia

# 带参数部署
npx hardhat ignition deploy ignition/modules/Token.ts \
  --parameters '{"name": "AwesomeToken", "symbol": "AWE", "initialSupply": "5000000"}' \
  --network sepolia
```

## 4.6 合约验证

### 4.6.1 自动验证

```bash
# 使用Hardhat验证
npx hardhat verify --network sepolia CONTRACT_ADDRESS "Constructor Arg1" "Arg2"

# 示例
npx hardhat verify --network sepolia 0x1234... "MyToken" "MTK" "1000000000000000000000000"
```

### 4.6.2 编程方式验证

```typescript
// scripts/verify.ts
import { run } from "hardhat";

async function verify(contractAddress: string, args: any[]) {
  console.log("正在验证合约...");
  try {
    await run("verify:verify", {
      address: contractAddress,
      constructorArguments: args,
    });
    console.log("✅ 合约验证成功");
  } catch (error: any) {
    if (error.message.toLowerCase().includes("already verified")) {
      console.log("合约已经验证过了");
    } else {
      console.error("验证失败:", error);
    }
  }
}

// 使用
await verify("0xYourContractAddress", ["MyToken", "MTK", ethers.parseEther("1000000")]);
```

## 4.7 测试网部署流程

### 完整部署检查清单

- [ ] ✅ 所有测试通过
- [ ] ✅ 代码已审计（对于主网）
- [ ] ✅ Gas优化完成
- [ ] ✅ 准备足够测试币
- [ ] ✅ 环境变量配置正确
- [ ] ✅ 网络配置正确
- [ ] ✅ 部署脚本已测试
- [ ] ✅ 合约参数正确
- [ ] ✅ 备份私钥和助记词

### 获取测试币

```
Sepolia Faucet:
- https://sepoliafaucet.com/
- https://faucet.quicknode.com/ethereum/sepolia

BSC Testnet Faucet:
- https://testnet.bnbchain.org/faucet-smart

Polygon Mumbai Faucet:
- https://faucet.polygon.technology/
```

### 部署命令

```bash
# 1. 编译合约
npx hardhat compile

# 2. 运行测试
npx hardhat test

# 3. 检查Gas报告
REPORT_GAS=true npx hardhat test

# 4. 部署到Sepolia
npx hardhat run scripts/deploy.ts --network sepolia

# 5. 验证合约
npx hardhat verify --network sepolia 0xContractAddress "Arg1" "Arg2"
```

---

## 📚 本章小结

WEB3测试是确保智能合约安全和正确性的关键步骤。通过Hardhat等专业工具，我们可以进行全面的单元测试、集成测试和部署验证，最大限度降低上线风险。

**下一章预告**：我们将进行一个完整的DApp项目实战 🚀

---

> 💡 **安全提示**：永远不要在代码中硬编码私钥，使用环境变量管理敏感信息！
